name: Deploy to AWS ECS

on:
  workflow_dispatch:  # Manual trigger only for challenge recording

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY || 'fsl-challenge-app' }}  # Added fallback
  ECS_CLUSTER: ${{ secrets.ECS_CLUSTER || 'fsl-challenge-cluster' }}
  ECS_SERVICE: ${{ secrets.ECS_SERVICE || 'fsl-challenge-service' }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Debug Environment Variables
      run: |
        echo "=== Environment Variables ==="
        echo "AWS_REGION: ${{ env.AWS_REGION }}"
        echo "ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}"
        echo "ECS_CLUSTER: ${{ env.ECS_CLUSTER }}"
        echo "ECS_SERVICE: ${{ env.ECS_SERVICE }}"
        echo "GITHUB_SHA: ${{ github.sha }}"
        echo "=========================="
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get AWS Account ID
      id: aws-account
      run: |
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID" >> $GITHUB_ENV
        echo "ECR_REGISTRY=$AWS_ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com" >> $GITHUB_ENV
        echo "âœ… AWS Account ID: $AWS_ACCOUNT_ID"
        echo "âœ… ECR Registry: $AWS_ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
    
    - name: Login to Amazon ECR
      id: login-ecr
      run: |
        echo "Logging into ECR registry: ${{ env.ECR_REGISTRY }}"
        aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
          docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}
        echo "âœ… Successfully logged into ECR"
    
    - name: Check/Create ECR Repository
      id: check-ecr
      run: |
        echo "Checking ECR repository: ${{ env.ECR_REPOSITORY }}"
        
        # Try to describe repository
        if aws ecr describe-repositories \
          --repository-names "${{ env.ECR_REPOSITORY }}" \
          --region "${{ env.AWS_REGION }}" > /dev/null 2>&1; then
          echo "âœ… ECR repository already exists"
          echo "ecr_exists=true" >> $GITHUB_OUTPUT
        else
          echo "Creating ECR repository: ${{ env.ECR_REPOSITORY }}"
          aws ecr create-repository \
            --repository-name "${{ env.ECR_REPOSITORY }}" \
            --region "${{ env.AWS_REGION }}"
          echo "âœ… Created ECR repository"
          echo "ecr_exists=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Prepare Application for Build
      id: prepare-app
      run: |
        echo "Preparing application for Docker build..."
        cd codebase/rdicidr-0.1.0
        
        # Display directory structure for debugging
        echo "=== Directory Structure ==="
        ls -la
        echo "========================="
        
        # Check package.json
        echo "=== Package.json ==="
        cat package.json || echo "No package.json found"
        echo "==================="
        
        # Create production Dockerfile if needed
        if [ ! -f Dockerfile ] || [ $(wc -l < Dockerfile 2>/dev/null || echo "0") -lt 3 ]; then
          echo "Creating Dockerfile.prod..."
          echo "FROM node:18-alpine as builder" > Dockerfile.prod
          echo "WORKDIR /app" >> Dockerfile.prod
          echo "COPY package*.json ./" >> Dockerfile.prod
          echo "RUN npm ci" >> Dockerfile.prod
          echo "COPY . ." >> Dockerfile.prod
          echo "RUN npm run build" >> Dockerfile.prod
          echo "" >> Dockerfile.prod
          echo "FROM nginx:alpine" >> Dockerfile.prod
          echo "COPY --from=builder /app/build /usr/share/nginx/html" >> Dockerfile.prod
          echo "RUN sed -i 's/listen\(.*\)80;/listen 8080;/' /etc/nginx/conf.d/default.conf" >> Dockerfile.prod
          echo "EXPOSE 8080" >> Dockerfile.prod
          echo 'CMD ["nginx", "-g", "daemon off;"]' >> Dockerfile.prod
        else
          echo "Using existing Dockerfile"
          cp Dockerfile Dockerfile.prod
        fi
        
        echo "âœ… Dockerfile.prod ready"
        echo "=== Dockerfile.prod content ==="
        cat Dockerfile.prod
        echo "==============================="
    
    - name: Build Docker Image
      id: build-image
      run: |
        echo "Building Docker image..."
        cd codebase/rdicidr-0.1.0
        
        # Construct full image name for debugging
        IMAGE_NAME="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}"
        echo "Image name: $IMAGE_NAME"
        echo "Building with tag: $IMAGE_NAME"
        
        # Build the Docker image
        docker build -f Dockerfile.prod -t "$IMAGE_NAME" .
        
        # Tag as latest
        LATEST_NAME="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:latest"
        docker tag "$IMAGE_NAME" "$LATEST_NAME"
        
        echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
        echo "LATEST_NAME=$LATEST_NAME" >> $GITHUB_ENV
        echo "âœ… Docker image built successfully"
        
        # List images for verification
        echo "=== Built Images ==="
        docker images | grep "${{ env.ECR_REPOSITORY }}"
    
    - name: Push Docker Image to ECR
      id: push-image
      run: |
        echo "Pushing Docker images to ECR..."
        echo "Pushing: ${{ env.IMAGE_NAME }}"
        docker push "${{ env.IMAGE_NAME }}"
        
        echo "Pushing: ${{ env.LATEST_NAME }}"
        docker push "${{ env.LATEST_NAME }}"
        
        echo "âœ… Images pushed to ECR successfully"
    
    - name: Create ECS Task Definition
      id: create-task-def
      run: |
        echo "Creating ECS task definition..."
        
        # Create task definition JSON file
        cat > task-definition.json << 'TASK_DEF_EOF'
{
  "family": "fsl-challenge-task",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "256",
  "memory": "512",
  "executionRoleArn": "arn:aws:iam::${AWS_ACCOUNT_ID}:role/ecsTaskExecutionRole",
  "taskRoleArn": "arn:aws:iam::${AWS_ACCOUNT_ID}:role/ecsTaskExecutionRole",
  "containerDefinitions": [
    {
      "name": "fsl-app",
      "image": "${IMAGE_NAME}",
      "portMappings": [
        {
          "containerPort": 8080,
          "hostPort": 8080,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {
          "name": "W_SECRET",
          "value": "OnBilltoribss"
        },
        {
          "name": "NODE_ENV",
          "value": "production"
        },
        {
          "name": "PORT",
          "value": "8080"
        }
      ],
      "essential": true,
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/fsl-challenge",
          "awslogs-region": "${AWS_REGION}",
          "awslogs-stream-prefix": "ecs"
        }
      },
      "healthCheck": {
        "command": ["CMD-SHELL", "curl -f http://localhost:8080/ || exit 1"],
        "interval": 30,
        "timeout": 5,
        "retries": 3,
        "startPeriod": 60
      }
    }
  ]
}
TASK_DEF_EOF
        
        # Replace variables in the JSON file
        sed -i "s|\${AWS_ACCOUNT_ID}|${{ env.AWS_ACCOUNT_ID }}|g" task-definition.json
        sed -i "s|\${IMAGE_NAME}|${{ env.IMAGE_NAME }}|g" task-definition.json
        sed -i "s|\${AWS_REGION}|${{ env.AWS_REGION }}|g" task-definition.json
        
        echo "=== Task Definition ==="
        cat task-definition.json
        echo "======================"
        
        # Register task definition
        TASK_DEF_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://task-definition.json \
          --region "${{ env.AWS_REGION }}" \
          --query "taskDefinition.taskDefinitionArn" \
          --output text)
        
        echo "TASK_DEF_ARN=$TASK_DEF_ARN" >> $GITHUB_ENV
        echo "âœ… Task definition created: $TASK_DEF_ARN"
    
    - name: Deploy to ECS
      id: deploy-ecs
      run: |
        echo "Deploying to ECS cluster: ${{ env.ECS_CLUSTER }}"
        
        # Check if ECS cluster exists, create if not
        if ! aws ecs describe-clusters \
          --clusters "${{ env.ECS_CLUSTER }}" \
          --region "${{ env.AWS_REGION }}" \
          --query "clusters[0].clusterName" \
          --output text > /dev/null 2>&1; then
          
          echo "Creating ECS cluster: ${{ env.ECS_CLUSTER }}"
          aws ecs create-cluster \
            --cluster-name "${{ env.ECS_CLUSTER }}" \
            --region "${{ env.AWS_REGION }}"
          echo "âœ… ECS cluster created"
        else
          echo "âœ… ECS cluster already exists"
        fi
        
        # Check if service exists
        SERVICE_STATUS=$(aws ecs describe-services \
          --cluster "${{ env.ECS_CLUSTER }}" \
          --services "${{ env.ECS_SERVICE }}" \
          --region "${{ env.AWS_REGION }}" \
          --query "services[0].status" \
          --output text 2>/dev/null || echo "NOT_FOUND")
        
        if [ "$SERVICE_STATUS" = "ACTIVE" ]; then
          echo "Updating existing ECS service..."
          aws ecs update-service \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --service "${{ env.ECS_SERVICE }}" \
            --task-definition "${{ env.TASK_DEF_ARN }}" \
            --force-new-deployment \
            --region "${{ env.AWS_REGION }}"
          echo "âœ… Service updated"
        else
          echo "Creating new ECS service..."
          
          # Get default VPC and subnets
          VPC_ID=$(aws ec2 describe-vpcs \
            --region "${{ env.AWS_REGION }}" \
            --filters "Name=is-default,Values=true" \
            --query "Vpcs[0].VpcId" \
            --output text)
          
          echo "Using VPC: $VPC_ID"
          
          SUBNET_IDS=$(aws ec2 describe-subnets \
            --region "${{ env.AWS_REGION }}" \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=default-for-az,Values=true" \
            --query "Subnets[0:2].SubnetId" \
            --output text | tr '\n' ',' | sed 's/,$//')
          
          echo "Using Subnets: $SUBNET_IDS"
          
          # Create security group
          SG_ID=$(aws ec2 create-security-group \
            --region "${{ env.AWS_REGION }}" \
            --group-name "fsl-challenge-sg-$(date +%s)" \
            --description "Security group for FSL Challenge" \
            --vpc-id "$VPC_ID" \
            --query "GroupId" \
            --output text)
          
          echo "Created Security Group: $SG_ID"
          
          # Allow HTTP traffic on port 8080
          aws ec2 authorize-security-group-ingress \
            --region "${{ env.AWS_REGION }}" \
            --group-id "$SG_ID" \
            --protocol tcp \
            --port 8080 \
            --cidr "0.0.0.0/0"
          
          # Create CloudWatch log group
          aws logs create-log-group \
            --log-group-name "/ecs/fsl-challenge" \
            --region "${{ env.AWS_REGION }}" 2>/dev/null || true
          
          # Create ECS service
          aws ecs create-service \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --service-name "${{ env.ECS_SERVICE }}" \
            --task-definition "${{ env.TASK_DEF_ARN }}" \
            --desired-count 1 \
            --launch-type "FARGATE" \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_IDS],securityGroups=[$SG_ID],assignPublicIp=ENABLED}" \
            --region "${{ env.AWS_REGION }}"
          
          echo "âœ… New ECS service created"
        fi
    
    - name: Wait for Deployment
      id: wait-deploy
      run: |
        echo "Waiting for deployment to stabilize..."
        
        # Wait for service to be created/updated
        sleep 30
        
        # Wait for service stability
        echo "Waiting for service to become stable..."
        aws ecs wait services-stable \
          --cluster "${{ env.ECS_CLUSTER }}" \
          --services "${{ env.ECS_SERVICE }}" \
          --region "${{ env.AWS_REGION }}" || echo "Service might still be initializing"
        
        echo "âœ… Deployment stabilized"
    
    - name: Get Service Endpoint
      id: get-endpoint
      run: |
        echo "Getting service endpoint..."
        
        # Get task information
        TASK_ARN=$(aws ecs list-tasks \
          --cluster "${{ env.ECS_CLUSTER }}" \
          --service-name "${{ env.ECS_SERVICE }}" \
          --region "${{ env.AWS_REGION }}" \
          --query "taskArns[0]" \
          --output text)
        
        if [ -n "$TASK_ARN" ] && [ "$TASK_ARN" != "None" ]; then
          echo "Found task: $TASK_ARN"
          
          # Get network interface ID
          ENI_ID=$(aws ecs describe-tasks \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --tasks "$TASK_ARN" \
            --region "${{ env.AWS_REGION }}" \
            --query "tasks[0].attachments[0].details[?name=='networkInterfaceId'].value" \
            --output text)
          
          if [ -n "$ENI_ID" ] && [ "$ENI_ID" != "None" ]; then
            echo "Network Interface: $ENI_ID"
            
            # Get public IP
            PUBLIC_IP=$(aws ec2 describe-network-interfaces \
              --network-interface-ids "$ENI_ID" \
              --region "${{ env.AWS_REGION }}" \
              --query "NetworkInterfaces[0].Association.PublicIp" \
              --output text)
            
            if [ -n "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "None" ]; then
              echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
              echo "âœ… Application deployed successfully!"
              echo "ðŸŒ Public IP: $PUBLIC_IP"
              echo "ðŸ”— Application URL: http://$PUBLIC_IP:8080"
              echo "ðŸ“Š Health check: http://$PUBLIC_IP:8080/health"
            else
              echo "âš ï¸ Could not retrieve public IP"
            fi
          else
            echo "âš ï¸ Could not find network interface"
          fi
        else
          echo "âš ï¸ No tasks found for service"
        fi
    
    - name: Test Deployment
      id: test-deploy
      if: env.PUBLIC_IP != ''
      run: |
        echo "Testing deployed application..."
        echo "Testing URL: http://${{ env.PUBLIC_IP }}:8080"
        
        # Test with retries
        MAX_RETRIES=10
        RETRY_COUNT=0
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          echo "Attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES..."
          
          if curl -s -f --max-time 10 "http://${{ env.PUBLIC_IP }}:8080" > /dev/null; then
            echo "âœ… Application is accessible!"
            
            # Test health endpoint if available
            curl -s "http://${{ env.PUBLIC_IP }}:8080/health" && echo "âœ… Health endpoint working" || echo "âš ï¸ Health endpoint not available"
            
            # Get app info
            echo "=== Application Info ==="
            curl -s "http://${{ env.PUBLIC_IP }}:8080" | head -c 200
            echo ""
            echo "======================"
            
            exit 0
          fi
          
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "Waiting 10 seconds before retry..."
          sleep 10
        done
        
        echo "âŒ Could not connect to application after $MAX_RETRIES attempts"
        exit 1
    
    - name: Create Deployment Summary
      if: always()
      run: |
        echo "## ðŸš€ FSL DevOps Challenge - Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ job.status }}" == "success" ]; then
          echo "### âœ… **DEPLOYMENT SUCCESSFUL**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -n "${{ env.PUBLIC_IP }}" ]; then
            echo "**ðŸŒ Application URL:** [http://${{ env.PUBLIC_IP }}:8080](http://${{ env.PUBLIC_IP }}:8080)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**ðŸ”— Health Check:** [http://${{ env.PUBLIC_IP }}:8080/health](http://${{ env.PUBLIC_IP }}:8080/health)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "**ðŸ“Š Deployment Details:**" >> $GITHUB_STEP_SUMMARY
          echo "- **AWS Region:** ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **ECR Repository:** ${{ env.ECR_REPOSITORY }}" >> $GITHUB_STEP_SUMMARY
          echo "- **ECS Cluster:** ${{ env.ECS_CLUSTER }}" >> $GITHUB_STEP_SUMMARY
          echo "- **ECS Service:** ${{ env.ECS_SERVICE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Task Definition:** fsl-challenge-task" >> $GITHUB_STEP_SUMMARY
          echo "- **Docker Image:** ${{ env.IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**ðŸ“ Challenge Requirements Met:**" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Application deployed as Docker container" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Available with public internet access" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Environment variable W_SECRET configured" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Running on AWS ECS Fargate" >> $GITHUB_STEP_SUMMARY
          
        else
          echo "### âŒ **DEPLOYMENT FAILED**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check the workflow logs above for detailed error information." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**ðŸ”§ Common Issues:**" >> $GITHUB_STEP_SUMMARY
          echo "1. AWS credentials not configured correctly" >> $GITHUB_STEP_SUMMARY
          echo "2. Missing IAM permissions for ECS/ECR" >> $GITHUB_STEP_SUMMARY
          echo "3. Docker build failure (check application code)" >> $GITHUB_STEP_SUMMARY
          echo "4. Network/VPC configuration issues" >> $GITHUB_STEP_SUMMARY
        fi
