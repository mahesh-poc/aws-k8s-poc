name: Deploy to AWS ECS

on:
  workflow_dispatch:  # Manual trigger only

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
  ECS_SERVICE: ${{ secrets.ECS_SERVICE }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      id: aws-creds
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get AWS Account ID
      id: aws-account
      run: |
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID" >> $GITHUB_ENV
        echo "ECR_REGISTRY=$AWS_ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com" >> $GITHUB_ENV
    
    - name: Login to Amazon ECR
      id: login-ecr
      run: |
        aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
        docker login --username AWS --password-stdin ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
    
    - name: Build Docker image
      id: build-image
      run: |
        echo "Building Docker image..."
        cd codebase/rdicidr-0.1.0
        
        # Check if we can build
        echo "Testing build..."
        ls -la
        
        # Create Dockerfile if it doesn't exist or is incomplete
        if [ ! -f Dockerfile ] || [ $(wc -l < Dockerfile) -lt 5 ]; then
          echo "Creating Dockerfile..."
          cat > Dockerfile << 'EOF'
          FROM node:18-alpine as builder
          WORKDIR /app
          COPY package*.json ./
          RUN npm ci
          COPY . .
          RUN npm run build
          
          FROM nginx:alpine
          COPY --from=builder /app/build /usr/share/nginx/html
          RUN sed -i 's/listen\(.*\)80;/listen 8080;/' /etc/nginx/conf.d/default.conf
          EXPOSE 8080
          CMD ["nginx", "-g", "daemon off;"]
          EOF
        fi
        
        # Build the image
        docker build -t ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }} .
        
        # Tag as latest
        docker tag ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }} ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:latest
        
        echo "IMAGE=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}" >> $GITHUB_ENV
    
    - name: Push Docker image to ECR
      run: |
        echo "Pushing Docker image to ECR..."
        docker push ${{ env.IMAGE }}
        docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:latest
    
    - name: Check if ECR repository exists
      id: check-ecr
      run: |
        if aws ecr describe-repositories \
          --repository-names ${{ env.ECR_REPOSITORY }} \
          --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "ECR repository exists"
          echo "ecr_exists=true" >> $GITHUB_OUTPUT
        else
          echo "ECR repository doesn't exist, creating..."
          aws ecr create-repository \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --region ${{ env.AWS_REGION }}
          echo "ecr_exists=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Deploy to ECS
      run: |
        echo "Deploying to ECS..."
        
        # First, create task definition if it doesn't exist
        cat > task-definition.json << EOF
        {
          "family": "fsl-challenge-task",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "512",
          "executionRoleArn": "arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole",
          "containerDefinitions": [
            {
              "name": "fsl-app",
              "image": "${{ env.IMAGE }}",
              "portMappings": [
                {
                  "containerPort": 8080,
                  "protocol": "tcp"
                }
              ],
              "environment": [
                {
                  "name": "W_SECRET",
                  "value": "OnBilltoribss"
                }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/fsl-challenge",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }
          ]
        }
        EOF
        
        # Register task definition
        aws ecs register-task-definition \
          --cli-input-json file://task-definition.json \
          --region ${{ env.AWS_REGION }}
        
        # Check if service exists
        if aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          
          echo "Updating existing ECS service..."
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition fsl-challenge-task \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}
            
        else
          echo "Creating new ECS service..."
          
          # Get default VPC and subnets
          VPC_ID=$(aws ec2 describe-vpcs \
            --region ${{ env.AWS_REGION }} \
            --filters "Name=is-default,Values=true" \
            --query "Vpcs[0].VpcId" \
            --output text)
          
          SUBNET_IDS=$(aws ec2 describe-subnets \
            --region ${{ env.AWS_REGION }} \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=default-for-az,Values=true" \
            --query "Subnets[0:2].SubnetId" \
            --output text | tr '\n' ' ' | sed 's/ $//')
          
          # Create security group
          SG_ID=$(aws ec2 create-security-group \
            --region ${{ env.AWS_REGION }} \
            --group-name "fsl-challenge-sg-$(date +%s)" \
            --description "Security group for FSL Challenge" \
            --vpc-id $VPC_ID \
            --query "GroupId" \
            --output text)
          
          aws ec2 authorize-security-group-ingress \
            --region ${{ env.AWS_REGION }} \
            --group-id $SG_ID \
            --protocol tcp \
            --port 8080 \
            --cidr 0.0.0.0/0
          
          # Create service
          aws ecs create-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service-name ${{ env.ECS_SERVICE }} \
            --task-definition fsl-challenge-task \
            --desired-count 1 \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_IDS],securityGroups=[$SG_ID],assignPublicIp=ENABLED}" \
            --region ${{ env.AWS_REGION }}
        fi
    
    - name: Wait for deployment
      run: |
        echo "Waiting for deployment to complete..."
        sleep 30  # Wait for service to start
        
        # Wait for service to stabilize
        aws ecs wait services-stable \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --region ${{ env.AWS_REGION }} || echo "Service might still be starting"
    
    - name: Get Public IP
      id: get-ip
      run: |
        echo "Getting service IP address..."
        
        # Get task ARN
        TASK_ARN=$(aws ecs list-tasks \
          --cluster ${{ env.ECS_CLUSTER }} \
          --service-name ${{ env.ECS_SERVICE }} \
          --region ${{ env.AWS_REGION }} \
          --query "taskArns[0]" \
          --output text) || echo "No tasks found"
        
        if [ -n "$TASK_ARN" ]; then
          echo "Task ARN: $TASK_ARN"
          
          # Get network interface
          ENI_ID=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --tasks $TASK_ARN \
            --region ${{ env.AWS_REGION }} \
            --query "tasks[0].attachments[0].details[?name=='networkInterfaceId'].value" \
            --output text) || echo "Could not get ENI ID"
          
          if [ -n "$ENI_ID" ]; then
            echo "ENI ID: $ENI_ID"
            
            # Get public IP
            PUBLIC_IP=$(aws ec2 describe-network-interfaces \
              --network-interface-ids $ENI_ID \
              --region ${{ env.AWS_REGION }} \
              --query "NetworkInterfaces[0].Association.PublicIp" \
              --output text) || echo "Could not get public IP"
            
            if [ -n "$PUBLIC_IP" ]; then
              echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
              echo "âœ… Application deployed!"
              echo "ðŸŒ URL: http://$PUBLIC_IP:8080"
              echo "ðŸ”— Health: http://$PUBLIC_IP:8080/health"
            else
              echo "âš ï¸ Could not get public IP, trying alternative method..."
              
              # Alternative: get the service's public DNS
              SERVICE_DETAILS=$(aws ecs describe-services \
                --cluster ${{ env.ECS_CLUSTER }} \
                --services ${{ env.ECS_SERVICE }} \
                --region ${{ env.AWS_REGION }} \
                --query "services[0].loadBalancers[0].dnsName" \
                --output text) || echo "No load balancer"
              
              if [ -n "$SERVICE_DETAILS" ] && [ "$SERVICE_DETAILS" != "None" ]; then
                echo "Load Balancer DNS: $SERVICE_DETAILS"
                echo "URL: http://$SERVICE_DETAILS"
              fi
            fi
          fi
        else
          echo "âš ï¸ No tasks running yet. The service might still be starting."
          echo "Check ECS console: https://${{ env.AWS_REGION }}.console.aws.amazon.com/ecs/home"
        fi
    
    - name: Test Deployment
      if: env.PUBLIC_IP != ''
      run: |
        echo "Testing deployed application..."
        
        # Wait a bit more for the app to start
        sleep 10
        
        # Test with retries
        for i in {1..10}; do
          echo "Attempt $i to connect..."
          if curl -s -f http://${{ env.PUBLIC_IP }}:8080/health > /dev/null; then
            echo "âœ… Health check passed!"
            curl -s http://${{ env.PUBLIC_IP }}:8080/health | head -c 100
            echo ""
            exit 0
          fi
          sleep 10
        done
        
        echo "âŒ Health check failed after 10 attempts"
        exit 1
    
    - name: Create deployment summary
      if: always()
      run: |
        echo "## ðŸš€ FSL Challenge Deployment" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ job.status }}" == "success" ]; then
          echo "### âœ… Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -n "${{ env.PUBLIC_IP }}" ]; then
            echo "**Application URL:** http://${{ env.PUBLIC_IP }}:8080" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Health Check:** http://${{ env.PUBLIC_IP }}:8080/health" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**AWS Resources:**" >> $GITHUB_STEP_SUMMARY
          echo "- Region: ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
          echo "- ECR Repository: ${{ env.ECR_REPOSITORY }}" >> $GITHUB_STEP_SUMMARY
          echo "- ECS Cluster: ${{ env.ECS_CLUSTER }}" >> $GITHUB_STEP_SUMMARY
          echo "- ECS Service: ${{ env.ECS_SERVICE }}" >> $GITHUB_STEP_SUMMARY
        else
          echo "### âŒ Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check the workflow logs above for details." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Troubleshooting:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Verify AWS credentials are correct" >> $GITHUB_STEP_SUMMARY
          echo "2. Check if ECR repository exists" >> $GITHUB_STEP_SUMMARY
          echo "3. Ensure ECS cluster exists" >> $GITHUB_STEP_SUMMARY
          echo "4. Check IAM permissions for ECS/ECR" >> $GITHUB_STEP_SUMMARY
        fi
